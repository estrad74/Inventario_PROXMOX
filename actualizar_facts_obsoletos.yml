---
- name: Recopilar facts
  hosts: all
  vars:
    awx_url: "{{ lookup('env', 'AWX_API_URL') }}"
    awx_token: "{{ lookup('env', 'AWX_OAUTH_TOKEN') }}"
    
    # Definición de configuraciones SSH por tipo de host
    ssh_configs:
      # Configuración para hosts modernos
      modern:
        common_args: >-
          -o StrictHostKeyChecking=no 
          -o UserKnownHostsFile=/dev/null
        transfer_method: piped
        
      # Configuración para hosts legacy que requieren RSA
      legacy_rsa:
        common_args: >-
          -o StrictHostKeyChecking=no 
          -o UserKnownHostsFile=/dev/null
          -o HostKeyAlgorithms=+ssh-rsa
          -o PubkeyAcceptedKeyTypes=+ssh-rsa
        transfer_method: piped
        
      # Configuración para hosts muy antiguos con problemas de libcrypto
      legacy_crypto:
        common_args: >-
          -o StrictHostKeyChecking=no 
          -o UserKnownHostsFile=/dev/null
          -o KexAlgorithms=+diffie-hellman-group1-sha1,diffie-hellman-group14-sha1,diffie-hellman-group-exchange-sha1
          -o Ciphers=+aes128-cbc,3des-cbc,aes192-cbc,aes256-cbc
          -o HostKeyAlgorithms=+ssh-rsa,ssh-dss
          -o PubkeyAcceptedKeyTypes=+ssh-rsa,ssh-dss
          -o MACs=+hmac-sha1,hmac-md5,hmac-md5-96,hmac-sha1-96
        transfer_method: piped
    
    # Variables para la conexión SSH, asignadas dinámicamente en las pre_tasks
    ansible_ssh_common_args: ""
    ansible_ssh_transfer_method: ""
    
  pre_tasks:
    - name: Determinar configuración SSH según el grupo
      set_fact:
        ssh_config_type: >-
          {% if 'hosts_muy_antiguos' in group_names %}legacy_crypto
          {% elif 'hosts_ssh_rsa' in group_names %}legacy_rsa
          {% else %}modern{% endif %}
    
    - name: Aplicar configuración SSH según el tipo
      set_fact:
        ansible_ssh_common_args: "{{ ssh_configs[ssh_config_type].common_args }}"
        ansible_ssh_transfer_method: "{{ ssh_configs[ssh_config_type].transfer_method }}"
    
    - name: Establecer variable OPENSSL_CONF para hosts antiguos
      set_fact:
        ansible_environment: 
          OPENSSL_CONF: "/etc/ssl/openssl.cnf.d/legacy.cnf"
      when: ssh_config_type == 'legacy_crypto'
    
    - name: Verificar conexión
      ping:
      register: ping_result
      ignore_errors: yes
      
    - name: Avisar sobre hosts no accesibles
      debug:
        msg: "No se pudo conectar al host {{ inventory_hostname }}. Se registrará con información limitada."
      when: ping_result is failed
  
  tasks:
    - name: Establecer variable de conexión exitosa
      set_fact:
        connection_successful: "{{ ping_result is success }}"

    - name: Recopilar facts estándar del sistema
      setup:
        gather_subset:
          - hardware
          - network
          - virtual
          - distribution
      register: setup_result
      ignore_errors: yes
      when: connection_successful | bool

    - name: Comprobar éxito en recopilación de facts
      set_fact:
        facts_successful: "{{ setup_result is success }}"
      when: connection_successful | bool

    - name: Recopilar información de paquetes instalados
      package_facts:
        manager: auto
      when: connection_successful | bool and facts_successful | bool
      ignore_errors: yes
      register: package_result
    
    - name: Extraer versiones de Python instaladas
      set_fact:
        python_versions_detected: "{{ python_versions_list | default([]) }}"
      vars:
        python_packages: "{{ ansible_facts.packages | dict2items | selectattr('key', 'match', '^python[0-9.]*$') | list }}"
        python_versions_list: >-
          {% set result = [] %}
          {% for pkg in python_packages %}
            {% for item in pkg.value %}
              {% set _ = result.append({'name': pkg.key, 'version': item.version}) %}
            {% endfor %}
          {% endfor %}
          {{ result }}
      when: connection_successful | bool and facts_successful | bool and package_result is success and ansible_facts.packages is defined

    - name: Extraer versiones de Java instaladas
      set_fact:
        java_versions_detected: "{{ java_versions_list | default([]) }}"
      vars:
        java_packages: "{{ ansible_facts.packages | dict2items | selectattr('key', 'search', 'openjdk|java') | list }}"
        java_versions_list: >-
          {% set result = [] %}
          {% for pkg in java_packages %}
            {% for item in pkg.value %}
              {% set _ = result.append({'name': pkg.key, 'version': item.version}) %}
            {% endfor %}
          {% endfor %}
          {{ result }}
      when: connection_successful | bool and facts_successful | bool and package_result is success and ansible_facts.packages is defined

    - name: Extraer versiones de Tomcat instaladas
      set_fact:
        tomcat_versions_detected: "{{ tomcat_versions_list | default([]) }}"
      vars:
        tomcat_packages: "{{ ansible_facts.packages | dict2items | selectattr('key', 'search', 'tomcat') | list }}"
        tomcat_versions_list: >-
          {% set result = [] %}
          {% for pkg in tomcat_packages %}
            {% for item in pkg.value %}
              {% set _ = result.append({'name': pkg.key, 'version': item.version}) %}
            {% endfor %}
          {% endfor %}
          {{ result }}
      when: connection_successful | bool and facts_successful | bool and package_result is success and ansible_facts.packages is defined

    - name: Construir diccionario con facts filtrados para hosts con conexión exitosa
      set_fact:
        filtered_system_facts:
          hostname: "{{ ansible_hostname | default(inventory_hostname) }}"
          fqdn: "{{ ansible_fqdn | default('') }}"
          ip: "{{ ansible_default_ipv4.address | default('') }}"
          os:
            name: "{{ ansible_distribution | default('Unknown') }}"
            version: "{{ ansible_distribution_version | default('Unknown') }}"
            release: "{{ ansible_distribution_release | default('') }}"
          kernel: "{{ ansible_kernel | default('Unknown') }}"
          architecture: "{{ ansible_architecture | default('Unknown') }}"
          memory_mb: "{{ ansible_memtotal_mb | default(0) }}"
          cpu_count: "{{ ansible_processor_count | default(0) }}"
          python_versions: "{{ python_versions_detected | default([]) }}"
          java_versions: "{{ java_versions_detected | default([]) }}"
          tomcat_versions: "{{ tomcat_versions_detected | default([]) }}"
          collected_at: "{{ lookup('pipe', 'date +%Y-%m-%dT%H:%M:%S') }}"
          collection_status: "successful"
          connection_type: "{{ ssh_config_type }}"
      when: connection_successful | bool and facts_successful | bool

    - name: Construir diccionario mínimo para hosts con error
      set_fact:
        filtered_system_facts:
          hostname: "{{ inventory_hostname }}"
          ip: "{{ ansible_host | default('') }}"
          collected_at: "{{ lookup('pipe', 'date +%Y-%m-%dT%H:%M:%S') }}"
          collection_status: "{{ 'connection_failed' if not connection_successful | bool else 'facts_failed' }}"
          error_type: "{{ 'libcrypto_error' if 'libcrypto' in (ping_result.msg | default('')) else 'unknown' }}"
          connection_type: "{{ ssh_config_type }}"
      when: not connection_successful | bool or not facts_successful | bool
          
    - name: Actualizar host en AWX con facts filtrados
      awx.awx.host:
        controller_host: "{{ awx_url }}"
        controller_oauthtoken: "{{ awx_token }}"
        inventory: "{{ awx_inventory_id }}"
        name: "{{ inventory_hostname }}"
        new_name: "{{ ansible_hostname | default(inventory_hostname) }}"
        validate_certs: false
        variables:
          original_name: "{{ original_name | default(inventory_hostname) }}"
          name: "{{ name | default(inventory_hostname) }}"
          hostname: "{{ hostname | default(inventory_hostname) }}"
          ansible_host: "{{ ansible_host | default(inventory_hostname) }}"
          connection_status: "{{ filtered_system_facts.collection_status }}"
          proxmox_agent: "{{ proxmox_agent | default('') }}"
          proxmox_agent_interfaces: "{{ proxmox_agent_interfaces | default('') }}"
          proxmox_boot: "{{ proxmox_boot | default('') }}"
          proxmox_cores: "{{ proxmox_cores | default('') }}"
          proxmox_cpu: "{{ proxmox_cpu | default('') }}"
          proxmox_digest: "{{ proxmox_digest | default('') }}"
          proxmox_hotplug: "{{ proxmox_hotplug | default('') }}"
          proxmox_ide0: "{{ proxmox_ide0 | default('') }}"
          proxmox_memory: "{{ proxmox_memory | default('') }}"
          proxmox_meta: "{{ proxmox_meta | default('') }}"
          proxmox_net0: "{{ proxmox_net0 | default('') }}"
          proxmox_node: "{{ proxmox_node | default('') }}"
          proxmox_numa: "{{ proxmox_numa | default('') }}"
          proxmox_ostype: "{{ proxmox_ostype | default('') }}"
          proxmox_qmpstatus: "{{ proxmox_qmpstatus | default('')}}"
          proxmox_scsi0: "{{ proxmox_scsi0 | default('') }}"
          proxmox_scsi1: "{{ proxmox_scsi1 | default('') }}"
          proxmox_scsi2: "{{ proxmox_scsi2 | default('') }}"
          proxmox_scsi3: "{{ proxmox_scsi3 | default('') }}"
          proxmox_scsihw: "{{ proxmox_scsihw | default('') }}"
          proxmox_snapshots: "{{ proxmox_snapshots | default('') }}"
          proxmox_sockets: "{{ proxmox_sockets | default('') }}"
          proxmox_status: "{{ proxmox_status | default('') }}"
          proxmox_vmgenid: "{{ proxmox_vmgenid | default('') }}"
          proxmox_vmid: "{{ proxmox_vmid | default('') }}"
          proxmox_vmtype: "{{ proxmox_vmtype | default('') }}"
          ansible_facts: "{{ filtered_system_facts }}"
      delegate_to: localhost
      throttle: 1
